{"config":{"lang":["en"],"separator":"[\\s\\-\\_,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>navis-fastcore</code>","text":"<p>Re-implementation of <code>navis</code> core function in Rust.</p> <p>Importantly, functions in <code>fastcore</code> are generalized and do not depend on <code>navis</code> itself. That way third-party libraries can make use of <code>fastcore</code> without the rather heavy dependency of <code>navis</code>. Currently, <code>fastcore</code> only requires <code>numpy</code>!</p> <p>In the future we might try to also provide R bindings for the underlying Rust functions so that they can also be used in e.g. the excellent natverse.</p> <p>At this point <code>fastcore</code> covers two areas where re-implementation made immediate sense:</p> <ol> <li>Operations on rooted tree graphs (= skeletons)</li> <li>NBLAST to get around the limitations of multi-processing in Python (experimental)</li> </ol> <p>Details &amp; available functions can be found the respective sections!</p>"},{"location":"#install","title":"Install","text":"<p>Pre-compiled binaries are on PyPI and can be installed via:</p> <pre><code>pip install navis-fastcore\n</code></pre> <p>Please see the Github repo if you need/want to build from source.</p>"},{"location":"#usage","title":"Usage","text":"<p><code>navis</code> will automatically use <code>fastcore</code> where appropriate. See the API docs if you want to use <code>fastcore</code> directly.</p>"},{"location":"NBLAST/","title":"NBLAST","text":"<p>There is an experimental implementation but this is very much still work in progress. In particular, we still need to:</p> <ol> <li>Properly test which Rust library to use for nearest-neighbor look-ups</li> <li>Match features in the pure Python implementation in <code>navis</code></li> </ol> <p>At this point, there is only a single function for a simple all-by-all NBLAST:</p> <pre><code>import fastcore\n\nimport numpy as np\n\nfrom collections import namedtuple\n\n# fastcore expects dotprops to be named tuple\nDotprop = namedtuple(\"Dotprop\", [\"points\", \"vect\"])\n\n# Generate 10 random dotprops\ndps = [\n    Dotprop(\n        np.random.rand(100, 3),\n        np.random.rand(100, 3)\n        )\n        for _ in range(10)\n        ]\n\nscores = fastcore.nblast_allbyall(dps)\n</code></pre>"},{"location":"Trees/","title":"Operations on Tree Graphs","text":"<p>Neurons can be represented as centerline skeletons which themselves are rooted trees, a special case of \"directed acyclic graphs\" (DAG) where each node has at most a single parent (root nodes will have no parents).</p> <p>Figure 1: Representing a neuron as directed acyclic graph.</p> <p>Rooted trees have two huge advantages over general graphs:</p> <p>First, they are super compact and can, at the minimum, be represented by just a single vector of parent indices (with root nodes having negative indices).</p> <p>Figure 2: Rooted tree graphs are compact.</p> <p>Second, they are much easier/faster to traverse because we can make certain assumptions that we can't for general graphs. For example, we know that there is only ever (at most) a single possible path between any pair of nodes.</p> <p>Figure 3: Finding the distance between two nodes.</p> <p>While <code>networkx</code> has some DAG-specific functions they don't implement anything related to graph traversal.</p>"},{"location":"Trees/#available-functions","title":"Available functions","text":"<p>The Python bindings for <code>navis-fastcore</code> currently cover the following functions:</p> <ul> <li><code>fastcore.geodesic_matrix</code>: calculate geodesic (\"along-the-arbor\") distances either between all pairs of nodes or between specific sources and targets</li> <li><code>fastcore.geodesic_pairs</code>: calculate geodesic (\"along-the-arbor\") distances between given pairs of nodes</li> <li><code>fastcore.connected_components</code>: generate the connected components</li> <li><code>fastcore.synapse_flow_centrality</code>: calculate synapse flow centrality (Schneider-Mizell, eLife, 2016)</li> <li><code>fastcore.break_segments</code>: break the neuron into the linear segments connecting leafs, branches and roots</li> <li><code>fastcore.generate_segments</code>: same as <code>break_segments</code> but maximize segment lengths, i.e. the longest segment will go from the most distal leaf to the root and so on</li> <li><code>fastcore.segment_coords</code>: generate coordinates per linear segment (useful for plotting)</li> <li><code>fastcore.prune_twigs</code>: removes terminal twigs below a certain size</li> <li><code>fastcore.strahler_index</code>: calculate Strahler index</li> </ul>"},{"location":"Trees/cc/","title":"Connected Components","text":""},{"location":"Trees/cc/#navis_fastcore.connected_components","title":"<code>navis_fastcore.connected_components(node_ids, parent_ids)</code>","text":"<p>Get the connected components for this neuron.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array of node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> RETURNS DESCRIPTION <code>cc</code> <p>For each node the node ID of its root (= connected component ID).</p> <p> TYPE: <code>(N, ) int32 array</code> </p> <p>Examples:</p> <p>Fully connected neuron:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; fastcore.connected_components(node_ids, parent_ids)\narray([0, 0, 0, 0, 0, 0, 0])\n</code></pre> <p>Introduce a break:</p> <pre><code>&gt;&gt;&gt; parent_ids[4] = -1\n&gt;&gt;&gt; fastcore.connected_components(node_ids, parent_ids)\narray([0, 0, 0, 0, 4, 4, 4])\n</code></pre>"},{"location":"Trees/geodesic/","title":"Geodesic Distances","text":""},{"location":"Trees/geodesic/#navis_fastcore.geodesic_matrix","title":"<code>navis_fastcore.geodesic_matrix(node_ids, parent_ids, directed=False, sources=None, targets=None, weights=None)</code>","text":"<p>Calculate geodesic (\"along-the-arbor\") distances.</p> Notes <p>Under-the-hood, this uses two different implementations depending on whether a full all-by-all or a partial (via <code>sources</code>/<code>targets</code>) matrix is requested. The partial implementation is faster and more memory efficient for small-ish subsets of nodes. However, for subsets that include a large portion of the nodes, it may be faster to calculate the full matrix and then subset it.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array of node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> <code>directed</code> <pre><code>     If ``True`` will only return distances in the direction of\n     the child -&gt; parent (i.e. towards the root) relationship.\n</code></pre> <p> TYPE: <code>  bool</code> DEFAULT: <code>False</code> </p> <code>sources</code> <pre><code>     Source node IDs. If ``None`` all nodes are used as sources.\n</code></pre> <p> TYPE: <code>   iterable</code> DEFAULT: <code>None</code> </p> <code>targets</code> <pre><code>     Target node IDs. If ``None`` all nodes are used as targets.\n</code></pre> <p> TYPE: <code>   iterable</code> DEFAULT: <code>None</code> </p> <code>weights</code> <pre><code>     Array of distances for each child -&gt; parent connection.\n     If ``None`` all node to node distances are set to 1.\n</code></pre> <p> TYPE: <code>   (N, ) float32 array</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>matrix</code> <p>Geodesic distances. Unreachable nodes are set to -1. If <code>source</code> and/or <code>targets</code> are provided, the matrix will be ordered accordingly.</p> <p> TYPE: <code>float32 (single) array</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; fastcore.geodesic_matrix(node_ids, parent_ids)\narray([[0., 1., 2., 3., 2., 3., 4.],\n       [1., 0., 1., 2., 1., 2., 3.],\n       [2., 1., 0., 1., 2., 3., 4.],\n       [3., 2., 1., 0., 3., 4., 5.],\n       [2., 1., 2., 3., 0., 1., 2.],\n       [3., 2., 3., 4., 1., 0., 1.],\n       [4., 3., 4., 5., 2., 1., 0.]], dtype=float32)\n&gt;&gt;&gt; fastcore.geodesic_matrix(\n...     node_ids, parent_ids,\n...     sources=[0, 1], targets=[5, 6]\n...     )\narray([[3., 4.],\n       [2., 3.]], dtype=float32)\n</code></pre>"},{"location":"Trees/geodesic/#navis_fastcore.geodesic_pairs","title":"<code>navis_fastcore.geodesic_pairs(node_ids, parent_ids, pairs, directed=False, weights=None)</code>","text":"<p>Calculate geodesic (\"along-the-arbor\") distances between pairs of nodes.</p> <p>This uses a simple algorithm that calculates distances using brute force. It's fast because we parallelize the calculation of each pair of nodes.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array of node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> <code>pairs</code> <pre><code>     Pairs of node IDs for which to calculate distances.\n</code></pre> <p> TYPE: <code>     (N, 2) array</code> </p> <code>directed</code> <pre><code>     If ``True`` will only return distances in the direction of\n     the child -&gt; parent (i.e. towards the root) relationship.\n</code></pre> <p> TYPE: <code>  bool</code> DEFAULT: <code>False</code> </p> <code>weights</code> <pre><code>     Array of distances for each child -&gt; parent connection.\n     If ``None`` all node to node distances are set to 1.\n</code></pre> <p> TYPE: <code>   (N, ) float32 array</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>matrix</code> <p>Geodesic distances. Unreachable nodes are set to -1.</p> <p> TYPE: <code>float32 (single) array</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; pairs = np.array([(0, 1), (0, 2)])\n&gt;&gt;&gt; fastcore.geodesic_pairs(node_ids, parent_ids, pairs)\n</code></pre>"},{"location":"Trees/morphology/","title":"Morphology","text":"<p>Functions related to analysing or manipulating neuron morpology.</p>"},{"location":"Trees/morphology/#navis_fastcore.synapse_flow_centrality","title":"<code>navis_fastcore.synapse_flow_centrality(node_ids, parent_ids, presynapses, postsynapses, mode='sum')</code>","text":"<p>Calculate synapse flow centrality for this neuron.</p> <p>Please note that this implementation currently produces slightly different results than the implementation in navis. I'm not sure why that is but the differences seem to be negligible.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array of int32 node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> <code>presynapses</code> <pre><code>     Array of number of presynapses associated with each node.\n</code></pre> <p> TYPE: <code>(N, ) uint32 array</code> </p> <code>postsynapses</code> <pre><code>     Array of number of postsynapses associated with each node.\n</code></pre> <p> TYPE: <code>(N, ) uint32 array</code> </p> <code>mode</code> <pre><code>     The mode to calculate the flow centrality. \"centrifugal\" will\n     calculate the flow from the root to the leaves, \"centripetal\"\n     will calculate the flow from the leaves to the root, and \"sum\"\n     will calculate the sum of both.\n</code></pre> <p> TYPE: <code>      \"centrifugal\" | \"centripetal\" | \"sum\"</code> DEFAULT: <code>'sum'</code> </p> RETURNS DESCRIPTION <code>cc</code> <p>Synapse flow centrality for each node.</p> <p> TYPE: <code>(N, ) uint32 array</code> </p>"},{"location":"Trees/morphology/#navis_fastcore.strahler_index","title":"<code>navis_fastcore.strahler_index(node_ids, parent_ids, method='standard', to_ignore=None, min_twig_size=None)</code>","text":"<p>Calculcate Strahler Index.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>            Array node IDs.\n</code></pre> <p> TYPE: <code>         (N, ) array</code> </p> <code>parent_ids</code> <pre><code>            Array of parent IDs for each node. Root nodes' parents\n            must be -1.\n</code></pre> <p> TYPE: <code>       (N, ) array</code> </p> <code>method</code> <pre><code>            Method used to calculate Strahler indices: 'standard'\n            will use the method described above; 'greedy' will\n            always increase the index at converging branches\n            whether these branches have the same index or not.\n</code></pre> <p> TYPE: <code>           'standard' | 'greedy'</code> DEFAULT: <code>'standard'</code> </p> <code>to_ignore</code> <pre><code>            List of node IDs to ignore. Must be the FIRST node\n            of the branch. Excluded branches will not contribute\n            to Strahler index calculations and instead be assigned\n            the SI of their parent branch.\n</code></pre> <p> TYPE: <code>        iterable</code> DEFAULT: <code>None</code> </p> <code>min_twig_size</code> <pre><code>            If provided, will ignore twigs with fewer nodes than\n            this. Instead, they will be assigned the SI of their\n            parent branch.\n</code></pre> <p> TYPE: <code>    int</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>strahler_index</code> <p>Strahler Index for each node.</p> <p> TYPE: <code>(N, ) int array</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(8)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5, 5])\n&gt;&gt;&gt; fastcore.strahler_index(node_ids, parent_ids)\narray([2, 2, 1, 1, 2, 2, 1, 1], dtype=int32)\n</code></pre>"},{"location":"Trees/morphology/#navis_fastcore.prune_twigs","title":"<code>navis_fastcore.prune_twigs(node_ids, parent_ids, threshold, weights=None, mask=None)</code>","text":"<p>Prune twigs shorter than a given threshold.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> <code>threshold</code> <pre><code>     Twigs shorter than this threshold will be pruned.\n</code></pre> <p> TYPE: <code> float</code> </p> <code>weights</code> <pre><code>     Array of distances for each child -&gt; parent connection.\n     If ``None`` all node-to-node distances are set to 1.\n</code></pre> <p> TYPE: <code>   (N, ) float32 array</code> DEFAULT: <code>None</code> </p> <code>mask</code> <pre><code>     Array of booleans to mask nodes that should not be pruned.\n     Importantly, twigs with _any_ masked node will not be pruned.\n</code></pre> <p> TYPE: <code>      (N, ) bool array</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>keep</code> <p>Node IDs to keep.</p> <p> TYPE: <code>(M, ) integer array</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; fastcore.prune_twigs(node_ids, parent_ids, 2)\narray([0, 1, 4, 5, 6])\n&gt;&gt;&gt; mask = np.array([True, True, True, False, True, True, True])\n&gt;&gt;&gt; fastcore.prune_twigs(node_ids, parent_ids, 2, mask=mask)\n</code></pre>"},{"location":"Trees/segments/","title":"Segments","text":"<p>For some operations (e.g. plotting) it is useful to break the graph into its linear components. You can do so by simply \"breaking\" the graph at each branch point, effectively producing linear segments that connect leafs, branch points and roots. Alternatively, you can try to make as few cuts as possible resulting in fewer and longer linear segments.</p> <p>Figure 1: Breaking neurons into linear components with as few cuts as possible. The alternative would be to introduce a break at node 2 resulting in 3 separate segments. This is the same toy skeleton used in the code examples below.</p>"},{"location":"Trees/segments/#generate-segments","title":"Generate Segments","text":""},{"location":"Trees/segments/#navis_fastcore.generate_segments","title":"<code>navis_fastcore.generate_segments(node_ids, parent_ids, weights=None)</code>","text":"<p>Generate linear segments maximizing segment lengths.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> <code>weights</code> <pre><code>     Array of distances for each child -&gt; parent connection.\n     If ``None`` all node-to-node distances are set to 1.\n</code></pre> <p> TYPE: <code>   (N, ) float32 array</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>segments</code> <p>Segments as list of arrays, sorted from longest to shortest. Each segment starts with a leaf and stops with a branch point or root node.</p> <p> TYPE: <code>list of arrays</code> </p> <code>lengths</code> <p>Length for each segment. If <code>weights</code> is provided this will be the physical length. Otherwise it will be the number of nodes.</p> <p> TYPE: <code>array</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; segs, length = fastcore.generate_segments(node_ids, parent_ids)\n&gt;&gt;&gt; segs\n[array([6, 5, 4, 1, 0]), array([3, 2, 1])]\n&gt;&gt;&gt; length\narray([5, 3], dtype=int32)\n</code></pre>"},{"location":"Trees/segments/#navis_fastcore.break_segments","title":"<code>navis_fastcore.break_segments(node_ids, parent_ids)</code>","text":"<p>Break neuron into linear segments connecting ends, branches and root.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>     Array node IDs.\n</code></pre> <p> TYPE: <code>  (N, ) array</code> </p> <code>parent_ids</code> <pre><code>     Array of parent IDs for each node. Root nodes' parents\n     must be -1.\n</code></pre> <p> TYPE: <code>(N, ) array</code> </p> RETURNS DESCRIPTION <code>segments</code> <p>Segments as list of arrays.</p> <p> TYPE: <code>list of arrays</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; fastcore.break_segments(node_ids, parent_ids)\n[array([1, 0]), array([3, 2]), array([6, 5, 4])]\n</code></pre>"},{"location":"Trees/segments/#segment-coordinates","title":"Segment Coordinates","text":""},{"location":"Trees/segments/#navis_fastcore.segment_coords","title":"<code>navis_fastcore.segment_coords(node_ids, parent_ids, coords, weights=None, node_colors=None)</code>","text":"<p>Generate coordinates for linear segments.</p> <p>This is useful for plotting the skeleton of a neuron.</p> PARAMETER DESCRIPTION <code>node_ids</code> <pre><code>        Array node IDs.\n</code></pre> <p> TYPE: <code>     (N, ) array</code> </p> <code>parent_ids</code> <pre><code>        Array of parent IDs for each node. Root nodes' parents\n        must be -1.\n</code></pre> <p> TYPE: <code>   (N, ) array</code> </p> <code>coords</code> <pre><code>        Array of coordinates for each node.\n</code></pre> <p> TYPE: <code>       (N, 3) array</code> </p> <code>node_colors</code> <pre><code>        A color for each node in `node_ids`. If provided, will\n        also return a list of colors sorted to match coordinates.\n</code></pre> <p> TYPE: <code>  (N, ) numpy.ndarray</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>seg_coords</code> <p> TYPE: <code>list of arrays</code> </p> <code>colors</code> <p>If <code>node_colors</code> provided will return a copy of it sorted to match <code>seg_coords</code>.</p> <p> TYPE: <code>list of colors</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import navis_fastcore as fastcore\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; node_ids = np.arange(7)\n&gt;&gt;&gt; parent_ids = np.array([-1, 0, 1, 2, 1, 4, 5])\n&gt;&gt;&gt; coords = np.random.rand(7, 3)\n&gt;&gt;&gt; fastcore.segment_coords(node_ids, parent_ids, coords)\n[array([[5.30713899e-01, 8.26450947e-01, 2.46805326e-01],\n        [1.54144332e-04, 9.07823578e-01, 3.20199043e-01],\n        [6.64580597e-01, 3.23724555e-01, 3.18361918e-01],\n        [7.16579499e-01, 8.65568868e-02, 7.15686948e-01],\n        [5.94874740e-01, 5.95528161e-01, 8.14234930e-01]]),\narray([[0.47814894, 0.84468164, 0.2765942 ],\n        [0.21748528, 0.36673489, 0.81449368],\n        [0.7165795 , 0.08655689, 0.71568695]])]\n</code></pre>"},{"location":"Wrappers/","title":"Scipy CSGraph Wrappers","text":"<p>If you are working with graphs (representing neurons or similar objects) you might already be using routines implemented in <code>scipy.csgraph</code> - for example, to compute distances or extract connected components.</p> <p>Assuming your graphs are rooted trees, you can use <code>fastcore</code> as drop-in replacement for some of these scipy functions:</p> <pre><code>&gt;&gt;&gt; from scipy.sparse import csr_array\n&gt;&gt;&gt; from navis_fastcore.wrappers.csgraph import dijkstra\n&gt;&gt;&gt; graph = [\n... [0, 1, 0, 0],\n... [0, 0, 0, 1],\n... [0, 0, 0, 3],\n... [0, 0, 0, 0]\n... ]\n&gt;&gt;&gt; graph = csr_array(graph)\n&gt;&gt;&gt; dist_matrix = dijkstra(csgraph=graph, directed=False)\n&gt;&gt;&gt; dist_matrix\narray([[0., 1., 5., 2.],\n       [1., 0., 4., 1.],\n       [5., 4., 0., 3.],\n       [2., 1., 3., 0.]], dtype=float32)\n</code></pre> <p><code>fastcore</code> currently implements the following <code>scipy.csgraph</code> functions:</p> <ul> <li><code>dijkstra</code></li> <li><code>connected_components</code></li> </ul>"},{"location":"Wrappers/#notes","title":"Notes","text":"<ol> <li>Not all arguments are supported. For example, <code>dijkstra</code> currently does not    support <code>return_predecessors=True</code>. See the docstrings for details!</li> <li>By default, these functions will perform a check to make sure the input graph    is actually directed and acyclic. These are generally fairly fast but if you    are confident in your graphs and want to save the odd millisecond, you can    set <code>checks=False</code>.</li> </ol>"}]}